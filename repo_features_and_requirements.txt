be able to use the top object detection models to train from (ex. faster-rcnn, retinanet, yolo)
change model training hyperparameters via a config file
log to tensorboard and mlflow
use lightning ai's various libraries (https://github.com/lightning-ai) as the ml framework to produce the modular and optimized code
be able to log various metrics to track experiments and use the mlflow model registry to register the best versions of each type of model
be easy to add and/or build out custom callbacks, metrics, and transforms
be able to easily ensemble multiple models together and train the ensemble
be able to optimize trained model (ex. using Tensor RT or lightning thunder) and save them off in a secure format such as a safe tensor
have the functionality to deploy optimized models for inference
have pipelines that users can submit training jobs too
uv (https://github.com/astral-sh/uv) should be used as the python package manager
use ruff (https://github.com/astral-sh/ruff) for code formatting and linting
use pyreflyfor type checking
doc strings for all classes and functions written in google format
documentation should be automatically generated (ex. using sphinx)
pre-commit should be configured
git commit should be written in a standard format using a template
a changelog should be created and updated automatically to track features, docs, bugfixes, removals
have a way to inference large images by slicing it up, running inference on the slices, and then stiching the results back together, sahi (https://github.com/obss/sahi) is a good package for this
have preprocessing functionality that can convert a dataset into an optimized dataset (using litdata)
yolo models should be able to be trained using the lightning framework and lightning datamodules instead of a data.yaml file
be aware that yolo models do not have a background class (index at 0) while torchvision models do (index at 1)
save off a confusion matrix to visualize model performance
ensure standardized, centeralized, and rotating logging is implemented (preferrably through the use of loguru and rich)
have the ability to easily turn on profiling for the codebase to find bottlenecks
have custom exceptions for more explict exception handling for easier debugging
unit tests using pytest should provide 80% code coverage
type hinting is mandatory
have a license file to include a copyright for the codebase
use dependabot (https://docs.github.com/en/code-security/how-tos/secure-your-supply-chain) in conjunction with uv to manage and maintain dependencies
use gitlab ci for merge request pipelines and to easily create a new release by updating the repo version using the semver standard, tag the repo with the new version, adn create a release, build and update the changelog, build and publish documentation to gitlab pages, create a bundle from the repository and add it as a release artifact
